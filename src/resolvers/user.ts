import { UserModel, UserRole } from '../models/User';
import jwt from 'jsonwebtoken';
import logger from '../utils/logger';

const JWT_SECRET: string = process.env.JWT_SECRET || 'eco-swift-secret-key-2024';
const JWT_EXPIRES_IN: string = process.env.JWT_EXPIRES_IN || '7d';

// Log JWT_SECRET status on module load (for debugging)
logger.info('User resolver JWT_SECRET configuration', {
  hasEnvVar: !!process.env.JWT_SECRET,
  secretLength: JWT_SECRET.length,
  secretPrefix: JWT_SECRET.substring(0, 10) + '...',
});

// Helper function to generate JWT token
function generateToken(userId: string): string {
  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN } as jwt.SignOptions);
}

// Types will be generated by codegen, using any for now
export const userResolvers: any = {
  Query: {
    me: async (_: any, __: any, { user }: { user: any }) => {
      if (!user) {
        throw new Error('Not authenticated');
      }
      return await UserModel.findById(user.userId).exec();
    },
    user: async (_: any, { id }: { id: string }) => {
      return await UserModel.findById(id).exec();
    },
    users: async (_: any, { limit = 10, offset = 0 }: { limit?: number; offset?: number }) => {
      return await UserModel.find()
        .limit(limit)
        .skip(offset)
        .exec();
    },
  },
  Mutation: {
    register: async (_: any, { input }: { input: any }) => {
      try {
        // Check if user already exists
        const existingUser = await UserModel.findOne({ email: input.email.toLowerCase() }).exec();
        if (existingUser) {
          throw new Error('User with this email already exists');
        }

        // Create new user
        const user = new UserModel({
          name: input.name,
          email: input.email.toLowerCase(),
          password: input.password, // Will be hashed by pre-save hook
          role: input.role,
        });

        await user.save();

        // Generate token
        const token = generateToken(user.id);

        // Return user without password - explicitly map fields to ensure they're included
        const userObj = user.toJSON();
        
        // Ensure all required fields are present
        return {
          token,
          user: {
            id: userObj.id || (user._id as any).toString(),
            name: userObj.name,
            email: userObj.email,
            role: userObj.role,
            avatar: userObj.avatar || null,
          },
        };
      } catch (error: any) {
        if (error.code === 11000) {
          throw new Error('User with this email already exists');
        }
        throw new Error(error.message || 'Failed to register user');
      }
    },
    login: async (_: any, { input }: { input: any }, _context: any) => {
      // Validate input
      if (!input || !input.email || !input.password) {
        throw new Error('Email and password are required');
      }

      try {
        // Find user by email and include password field
        const user = await UserModel.findOne({ email: input.email.toLowerCase() })
          .select('+password')
          .exec();

        if (!user) {
          throw new Error('Invalid email or password');
        }

        // Verify password
        if (!user.password) {
          throw new Error('User password is missing');
        }

        const isPasswordValid = await user.comparePassword(input.password);
        if (!isPasswordValid) {
          throw new Error('Invalid email or password');
        }

        // Get user ID - try both id and _id
        const userId = (user as any).id || (user as any)._id?.toString();
        if (!userId) {
          throw new Error('User ID is missing');
        }
        
        // Generate token
        const token = generateToken(userId);
        if (!token) {
          throw new Error('Failed to generate token');
        }

        // Get user data - use toJSON to ensure proper transformation
        const userObj = user.toJSON();
        
        // Validate required fields
        if (!userObj || !userObj.name || !userObj.email || !userObj.role) {
          throw new Error('User data is incomplete');
        }
        
        // Build auth payload
        const authPayload = {
          token: token,
          user: {
            id: userObj.id || userId,
            name: String(userObj.name),
            email: String(userObj.email),
            role: String(userObj.role),
            avatar: userObj.avatar || null,
          },
        };

        // Final validation - ensure nothing is null/undefined
        if (!authPayload.token || 
            !authPayload.user || 
            !authPayload.user.id || 
            !authPayload.user.name || 
            !authPayload.user.email || 
            !authPayload.user.role) {
          logger.error('Auth payload validation failed', { authPayload });
          throw new Error('Failed to generate authentication payload');
        }

        logger.info('User logged in successfully', { userId: authPayload.user.id, email: authPayload.user.email, role: authPayload.user.role });
        return authPayload;
      } catch (error: any) {
        // Log the error
        logger.error('Login failed', {
          message: error.message,
          email: input.email,
          role: input.role,
          stack: error.stack,
        });
        
        // Always throw an error, never return null or undefined
        const errorMessage = error.message || 'Failed to login';
        throw new Error(errorMessage);
      }
    },
    updateUser: async (_: any, { input }: { input: any }, { user }: { user: any }) => {
      if (!user) {
        throw new Error('Not authenticated');
      }

      const updateData: any = { ...input };
      // Remove undefined fields
      Object.keys(updateData).forEach(key => {
        if (updateData[key] === undefined) {
          delete updateData[key];
        }
      });

      const updatedUser = await UserModel.findByIdAndUpdate(
        user.userId,
        updateData,
        { new: true }
      ).exec();

      if (!updatedUser) {
        throw new Error('User not found');
      }

      return updatedUser.toJSON();
    },
    changePassword: async (_: any, { oldPassword, newPassword }: { oldPassword: string; newPassword: string }, { user }: { user: any }) => {
      if (!user) {
        throw new Error('Not authenticated');
      }

      const userDoc = await UserModel.findById(user.userId)
        .select('+password')
        .exec();

      if (!userDoc) {
        throw new Error('User not found');
      }

      // Verify old password
      const isPasswordValid = await userDoc.comparePassword(oldPassword);
      if (!isPasswordValid) {
        throw new Error('Invalid old password');
      }

      // Update password (will be hashed by pre-save hook)
      userDoc.password = newPassword;
      await userDoc.save();

      return true;
    },
    logout: async () => {
      // In a stateless JWT system, logout is handled client-side by removing the token
      // You could implement token blacklisting here if needed
      return true;
    },
  },
  User: {
    products: async (user: any) => {
      // Import ProductModel here to avoid circular dependency
      const { ProductModel } = await import('../models/Product.js');
      return await ProductModel.find({ vendor: user.id }).exec();
    },
  },
};

