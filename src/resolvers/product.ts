import { ProductModel } from '../models/Product';
import { CategoryModel } from '../models/Category';
import { pubsub, SUBSCRIPTION_EVENTS } from './subscription';

// Types will be generated by codegen, using any for now
export const productResolvers: any = {
  Query: {
    products: async (_: any, { limit = 10, offset = 0, categoryId, featured, vendorId, search }: { limit?: number; offset?: number; categoryId?: string; featured?: boolean; vendorId?: string; search?: string }) => {
      const query: any = {};
      
      if (categoryId) {
        query.category = categoryId;
      }
      
      if (featured !== undefined) {
        query.isFeatured = featured;
      }
      
      if (vendorId) {
        query.vendor = vendorId;
      }
      
      if (search) {
        query.$or = [
          { name: { $regex: search, $options: 'i' } },
          { description: { $regex: search, $options: 'i' } },
          { sku: { $regex: search, $options: 'i' } },
        ];
      }
      
      return await ProductModel.find(query)
        .limit(limit)
        .skip(offset)
        .populate('category')
        .populate('vendor')
        .exec();
    },
    product: async (_: any, { id }: { id: string }) => {
      return await ProductModel.findById(id)
        .populate('category')
        .populate('vendor')
        .exec();
    },
    categories: async () => {
      return await CategoryModel.find().exec();
    },
    category: async (_: any, { id }: { id: string }) => {
      return await CategoryModel.findById(id).exec();
    },
    relatedProducts: async (_: any, { productId, limit = 4 }: { productId: string; limit?: number }) => {
      // Find the current product to get its category
      const currentProduct = await ProductModel.findById(productId).exec();
      
      if (!currentProduct || !currentProduct.category) {
        return [];
      }
      
      // Find products in the same category, excluding the current product
      const relatedProducts = await ProductModel.find({
        category: currentProduct.category,
        _id: { $ne: productId }, // Exclude current product
      })
        .limit(limit)
        .populate('category')
        .populate('vendor')
        .exec();
      
      return relatedProducts;
    },
  },
  Mutation: {
    createProduct: async (_: any, { input }: { input: any }, { user }: { user: any }) => {
      if (!user) {
        throw new Error('Not authenticated');
      }
      
      const product = new ProductModel({
        ...input,
        category: input.categoryId,
        vendor: user.userId, // Set vendor from authenticated user
      });
      const saved = await product.save();
      const populatedProduct = await ProductModel.findById(saved._id)
        .populate('category')
        .populate('vendor')
        .exec();
      
      // Publish subscription event to vendor-specific channel
      pubsub.publish(`${SUBSCRIPTION_EVENTS.PRODUCT_CREATED}_${user.userId}`, {
        productCreated: populatedProduct,
      });
      
      // Also publish to general channel for public subscriptions (e.g., featured products)
      pubsub.publish(SUBSCRIPTION_EVENTS.PRODUCT_CREATED, {
        productCreated: populatedProduct,
      });
      
      return populatedProduct;
    },
    updateProduct: async (_: any, { id, input }: { id: string; input: any }, { user }: { user: any }) => {
      if (!user) {
        throw new Error('Not authenticated');
      }
      
      // Check if product exists and belongs to vendor
      const product = await ProductModel.findById(id).exec();
      if (!product) {
        throw new Error('Product not found');
      }
      
      if (product.vendor.toString() !== user.userId) {
        throw new Error('Not authorized to update this product');
      }
      
      const updateData: any = { ...input };
      if (input.categoryId) {
        updateData.category = input.categoryId;
        delete updateData.categoryId;
      }
      
      const updatedProduct = await ProductModel.findByIdAndUpdate(id, updateData, { new: true })
        .populate('category')
        .populate('vendor')
        .exec();
      
      // Publish subscription event to vendor-specific channel
      pubsub.publish(`${SUBSCRIPTION_EVENTS.PRODUCT_UPDATED}_${user.userId}`, {
        productUpdated: updatedProduct,
      });
      
      // Also publish to general channel for public subscriptions (e.g., featured products)
      pubsub.publish(SUBSCRIPTION_EVENTS.PRODUCT_UPDATED, {
        productUpdated: updatedProduct,
      });
      
      return updatedProduct;
    },
    deleteProduct: async (_: any, { id }: { id: string }, { user }: { user: any }) => {
      if (!user) {
        throw new Error('Not authenticated');
      }
      
      // Check if product exists and belongs to vendor
      const product = await ProductModel.findById(id).exec();
      if (!product) {
        throw new Error('Product not found');
      }
      
      if (product.vendor.toString() !== user.userId) {
        throw new Error('Not authorized to delete this product');
      }
      
      // Store product info before deletion for subscription
      const productInfo = {
        id: product.id,
        name: product.name,
        deletedAt: new Date(),
      };
      
      await ProductModel.findByIdAndDelete(id).exec();
      
      // Publish subscription event to vendor-specific channel
      pubsub.publish(`${SUBSCRIPTION_EVENTS.PRODUCT_DELETED}_${user.userId}`, {
        productDeleted: productInfo,
      });
      
      // Also publish to general channel for public subscriptions (e.g., featured products)
      pubsub.publish(SUBSCRIPTION_EVENTS.PRODUCT_DELETED, {
        productDeleted: productInfo,
      });
      
      return true;
    },
  },
  Product: {
    category: async (product: any) => {
      if (product.category && typeof product.category === 'object') {
        return product.category as any;
      }
      return await CategoryModel.findById(product.category).exec();
    },
  },
  Category: {
    products: async (category: any) => {
      return await ProductModel.find({ category: category.id }).exec();
    },
  },
};

